# ROP的原理
nX-U16中，“nX”代表“No Execute”，也就是不可执行。具体来说，CPU只能执行ROM中的代码，RAM是不能当作代码来运行的。这似乎给我们计算器的编程判了死刑。但是，其实还有一种办法可以让计算器执行我们想要的代码，这就是ROP。

上一章提到过，许多函数都会用`PUSH LR`备份LR，并用`POP PC`返回，返回的地址就存在栈上。如果用我们自己的数据覆盖掉这个返回地址，就能让CPU跳转到任何我们想要的地方。ROP的基本原理就是这样的。（ROP的全称就是Return-Oriented Programming，即面向返回编程）假设我们需要CPU执行一个函数。如果跳转到函数开头的`PUSH LR`，由于此处LR的值是不可控的，所以函数执行完以后，`POP PC`就会跳到不知道什么地方去。如果跳转到`PUSH LR`下一条指令，那么函数执行完以后还要`POP PC`，但是没有对应的PUSH，所以它会从栈上再取一个值。如果跳到函数的中间，那就会从中间开始执行。如果一开始还有别的PUSH，那后面就会有对应的POP，因此函数退出时会取更多的值。只要按照这个规则把所有要执行的函数地址按顺序放到栈上，CPU就会为我们做事！

说了这么多，到底怎么覆盖栈呢？前人已经为我们准备了一个办法。在线性模式中，没有重做缓冲区。取而代之的是，每次按下等号时会把当前输入的算式复制到0xD522处，计算器会在这里解析那个算式。由于字符FD20（an）的特性，算式中的an被解析时会修改SP的值。一般来说，计算器的SP都在0xEC00以后，而an会把它放到0xD522附近。进入x an模式（x表示an前的字节数，如124an就是an前面124个字节）以后，在按下=或CALC时，负责复制输入区的函数会把LR存储到0xD4D6+x处。例如，124an中，这个地址为0xD4D6+124=0xD552=0xD522+48。也就是说，输入区从第48个字节开始的内容会被覆盖到栈上。为了方便，可以用公式76+x算出覆盖开始的地方。
# ROP的简单实例
## 示例1：自检
通过阅读源代码，我们发现（代码反编译是一件非常漫长且非常困难的工作。幸运的是，前人已经有了一些工作积累。可以在labels.txt中看到一些函数的地址，但计算器里的函数远远不止这些，更多的函数有待进一步反编译），自检函数位于22040处。这里摘录几行源代码：
```
2203E  BC AL, 2213A
22040  PUSH LR
22042  PUSH QR0
22044  MOV R1, 1
```
根据刚才讲过的规则，我们决定跳转到22042处。为了简便，在线性复数模式中进入76an（an前76个数字，=），然后输入`42 20 32`（Ai2），按=，就进入自检了。现在分析一下这段非常短的ROP。76an中，输入的第一个字节就会覆盖到栈上，因此按下=时，栈里就是`42 20 32 00`。（复制到NUL位置，你应该还记得）然后负责复制的那个函数`POP PC`，PC就变为22042。（前面讲过，PC只有2.5个字节，所以后面的1.5个字节就没了。所以说打的那个2，其实可以是任何后面一半是2的字符，只是打2最方便）跳转到22042就进入了自检函数。其实跳转到22040也是可以的，因为我们这里只有一条指令，自检函数返回到哪里我们并不在乎。
## 示例2：拼字
labels告诉我们，地址220FE可以按照二级字符表，在屏幕第三行显示出ER2指向的一行字符串并显示PRESS AC，然后卡死，不返回。调用它就能实现拼字的效果，但是我们需要先让ER2指向要显示的那个字符串。幸运的是，不需要这么做！负责复制的函数会自动把ER2设置为0xD180，也就是输入区的开头。因此，只要把那个字符串打在输入区开头，然后调用220FE即可。

进入110an（不能直接运算110个数字。此处可以100数字，+，9数字，an），输入想要显示的字符串（需要按照一级字符表转换）。一行17个字符，简单起见，这里就打12345678901234567。110=76+34，因此ROP会从第34个字节开始执行。凑满34字节，然后打出FE 20 32（Pa>kgf/in22），打完后按等于即可。那为什么要用110an，而不是94an呢？因为，执行220FE这个函数的时候，必定要先PUSH一些值，不能让这些值覆盖了我们的字符串，所以中间要隔开一些字节。
## 示例3：定向拼字
假设你希望显示其他地方的字符串。那就需要给ER2赋值。怎么赋值呢？我们的数据全在栈上，因此要从栈转移数据到寄存器里，自然地就想到了POP指令。我们在ROM里找到了这么一个东西：
```
08FC2  POP ER2
08FC4  POP PC
```
只要调用08FC2，就可以给ER2赋值了。还是进入110an模式。我们应该打的是`（垫34字节）C2 8F _0 __ （要显示的地址） FE 20 _2`。其中_表示什么值都可以。C2不能直接打出，所以要用@（4D）来刷。注意，用@刷字符必须要按等于，如果an位移太少，就会在这个时候触发rop，所以an位移一定要大一些。
## 示例4：双行拼字
之前用的220FE执行完就会卡死，不会返回。如果要拼两行，必定要选择一个能返回的函数，这样才有机会显示下一行。这里我们选择221AE。这个函数接受两个参数，r0=显示在第几行（以像素为单位），er2=字符串的地址。为了给r0赋值，可以用这段ROM：
```
121A8  POP ER0
121AA  POP PC
```
除此之外，还要了解221AE的一个性质：它显示完一行以后，会自动把ER2往后移到下一行那里，所以不用手动给ER2赋值。有了这些知识，就能构造ROP链了：

`A8 21 _1 __ 01 __ AE 21 _2 __ FE 20 _2`

其中，01是显示的位置，就是第1行。（第0行对应上面的指示灯。）我们发现ROP里面有一个不能直接打出的字符01。但是这里没有必要用@刷字符了。看字符表可以发现，字符FE01（in>cm）可以直接打出，而且01前面恰好是可以随便打的。因此我们要打的就是：

`（34字节）A8 21 _1 FE 01 __ AE 21 _2 __ FE 20 _2`

还是照例进入110an，垫34字节后输入ROP链即可。
## 示例5：按键交互
函数221C4会不断等待，直到按下SHIFT才会返回。我们就用这个函数来实现简单的按键交互。这一次先简单一点，我们希望按下SHIFT再显示拼字内容。但是注意，调用221C4后，ER2的值就没了，因此我们要手动赋值。ROP链：

`C4 21 _2 __ C2 8F _0 __ 80 D1 FE 20 _2`

输入方法和前面几个ROP一样，110an，注意C4 C2 80 D1这四个字符要用@刷。
## 示例6：加法
```
08F24  L ER10, [ER8]
08F26  ADD ER2, ER10
08F28  ST ER2, [ER8]
08F2A  POP XR8
08F2C  POP PC
```
分析这段代码，可以发现，它把ER8指向的值增加了ER2。我们接下来就要用它实现一项功能：显示字符串，按下SHIFT后让最后一个字符+1，并再次显示字符串。另外，使用加法需要给ER8赋值。我们用这个：
```
2237C  POP QR8
2237E  POP QR0
22380  POP PC
```
这是因为它可以同时更新ER2和ER8。
据此构造出ROP链：
```
A8 21 _1 __ 01 __ AE 21 _2 __ C4 21 _2 __ 7C 23
_2 __ 90 D1 __ __ __ __ __ __ __ __ 01 __ __ __
__ __ 8F 24 _0 __ __ __ __ __ C2 8F _0 __ 80 D1
FE 20 _2
```
这次的ROP长了很多，我们分指令解释。第一条`A8 21 _1 __ 01 __`给R0赋值为01。然后紧接着`AE 21 _2 __`显示字符串。接下来`C4 21 _2 __`等待按SHIFT。第四条`7C 23 _2 __ 90 D1 __ __ __ __ __ __ 01 __ 01 __ __ __ __ __`把ER8赋值为0xD190，ER2赋值为01（加数）。第五条`8F 24 _0 __ __ __ __ __`执行加法。注意它最后有个POP XR8，所以要给它多留4字节的栈空间。第六条`C2 8F _0 __ 80 D1`给ER2赋值为0xD180。最后`FE 20 _2`重新输出字符串。

不知你有没有发现，08F24其实执行的是双字节加法。不过，我们只会显示到D190为止，所以只要低字节+1即可，高字节变成了几我们不在乎。